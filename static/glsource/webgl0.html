<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>헬로 월드</title>
    <style>
      /* Licensed under a BSD license. See ../license.html for license */

      html {
        box-sizing: border-box;
      }
      *,
      *:before,
      *:after {
        box-sizing: inherit;
        user-select: none;
      }

      body {
        background-color: #aaa;
        font-family: Sans-Serif;
      }

      canvas {
        background-color: #fff;
        border: 1px solid black;
        /* NOTE: This size is changed if in iframe - see below '.iframe canvas' */
        width: 400px;
        height: 300px;
        display: block;
      }

      #uiContainer {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 3;
        font-family: monospace;
        pointer-events: none;

        text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff,
          1px 1px 0 #fff;
      }
      #ui {
        opacity: 0.8;
      }
      #ui > div {
        pointer-events: none;
      }
      #ui input,
      #ui select,
      #ui option,
      #ui canvas {
        pointer-events: auto;
      }

      .gman-slider-label,
      .gman-widget-label,
      .gman-checkbox-label {
        font-size: small;
        min-width: 10em;
        text-align: right;
      }
      .gman-checkbox-label {
        pointer-events: auto;
      }
      .gman-widget-value {
        float: right;
        font-size: small;
        order: 1;
        min-width: 3em;
      }

      .gman-slider-upper {
        height: 1.5em;
      }
      .gman-slider-outer,
      .gman-widget-outer {
        float: right;
        display: flex;
        align-items: center;
        height: 1.7em;
      }
      .gman-widget-slider,
      .gman-widget-checkbox,
      .gman-widget-select {
        opacity: 0.5;
        font-size: large;
        margin-left: 0.3em;
        margin-right: 0.3em;
      }
      .gman-widget-select {
        font-size: small;
      }
      .gman-widget-slider {
        min-width: 120px;
      }

      /* styles to apply if in an iframe */

      html.iframe {
        height: 100vh;
      }
      body.iframe {
        width: 100vw;
        height: 100vh;
        margin: 0;
        overflow: hidden;
      }

      .iframe > .description {
        display: none;
      }
      .iframe .divcanvas {
        width: 100vw;
        height: 100vh;
      }
      .iframe canvas {
        width: 100vw;
        height: 100vh;
        max-width: 100vw;
        border: none;
      }

      .iframe > #example {
        width: 100%;
        height: 100%;
      }
      #ui #rotation > canvas {
        background-color: rgba(255, 255, 255, 0.6);
      }
      #ui {
        width: 200px;
      }

      @media (max-width: 390px) {
        pre {
          font-size: xx-small !important;
          max-width: 300px !important;
        }
        canvas {
          width: 100vw;
        }
        .iframe canvas {
          width: 100vw;
          height: 100vh;
          border: none;
        }
        #uiContainer {
          top: 120px;
        }
        .iframe #uiContainer {
          top: 10px;
        }
      }

      @media (prefers-color-scheme: dark) {
        #ui .ui-dark-support {
          color: white;
          text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000,
            1px 1px 0 #000;
        }
      }

      body {
        margin: 0;
      }
      canvas {
        width: 100vw;
        height: 100vh;
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <h4>_</h4>

    <script src="https://webgl2fundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script>
      "use strict";

      var vertexShaderSource = `#version 300 es

// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
in vec4 a_position;

// all shaders have a main function
void main() {

  // gl_Position is a special variable a vertex shader
  // is responsible for setting
  gl_Position = a_position;
}
`;

      var fragmentShaderSource = `#version 300 es

// fragment shaders don't have a default precision so we need
// to pick one. highp is a good default. It means "high precision"
precision highp float;

// we need to declare an output for the fragment shader
out vec4 outColor;

void main() {
  // Just set the output to a constant redish-purple
  outColor = vec4(1, 0, 0.5, 1);
}
`;

      function createShader(gl, type, source) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
          return shader;
        }

        console.log(gl.getShaderInfoLog(shader)); // eslint-disable-line
        gl.deleteShader(shader);
        return undefined;
      }

      function createProgram(gl, vertexShader, fragmentShader) {
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        var success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (success) {
          return program;
        }

        console.log(gl.getProgramInfoLog(program)); // eslint-disable-line
        gl.deleteProgram(program);
        return undefined;
      }

      function main() {
        // Get A WebGL context
        var canvas = document.querySelector("#c");
        var gl = canvas.getContext("webgl2");
        if (!gl) {
          return;
        }

        // create GLSL shaders, upload the GLSL source, compile the shaders
        var vertexShader = createShader(
          gl,
          gl.VERTEX_SHADER,
          vertexShaderSource
        );
        var fragmentShader = createShader(
          gl,
          gl.FRAGMENT_SHADER,
          fragmentShaderSource
        );

        // Link the two shaders into a program
        var program = createProgram(gl, vertexShader, fragmentShader);

        // look up where the vertex data needs to go.
        var positionAttributeLocation = gl.getAttribLocation(
          program,
          "a_position"
        );

        // Create a buffer and put three 2d clip space points in it
        var positionBuffer = gl.createBuffer();

        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        var positions = [0, 0, -1, 1, -1, -1];
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(positions),
          gl.STATIC_DRAW
        );

        // Create a vertex array object (attribute state)
        var vao = gl.createVertexArray();

        // and make it the one we're currently working with
        gl.bindVertexArray(vao);

        // Turn on the attribute
        gl.enableVertexAttribArray(positionAttributeLocation);

        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
        var size = 2; // 2 components per iteration
        var type = gl.FLOAT; // the data is 32bit floats
        var normalize = false; // don't normalize the data
        var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position
        var offset = 0; // start at the beginning of the buffer
        gl.vertexAttribPointer(
          positionAttributeLocation,
          size,
          type,
          normalize,
          stride,
          offset
        );

        webglUtils.resizeCanvasToDisplaySize(gl.canvas);

        // Tell WebGL how to convert from clip space to pixels
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        // Clear the canvas
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Tell it to use our program (pair of shaders)
        gl.useProgram(program);

        // Bind the attribute/buffer set we want.
        gl.bindVertexArray(vao);

        // draw
        var primitiveType = gl.TRIANGLES;
        var offset = 0;
        var count = 3;
        gl.drawArrays(primitiveType, offset, count);
      }

      main();
    </script>
  </body>
</html>
